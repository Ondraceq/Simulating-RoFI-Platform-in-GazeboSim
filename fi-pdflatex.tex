%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
  digital, %% The `digital` option enables the default options for the
           %% digital version of a document. Replace with `printed`
           %% to enable the default options for the printed version
           %% of a document.
%%  color,   %% Uncomment these lines (by removing the %% at the
%%           %% beginning) to use color in the digital version of your
%%           %% document
  table,   %% The `table` option causes the coloring of tables.
           %% Replace with `notable` to restore plain LaTeX tables.
  oneside, %% The `twoside` option enables double-sided typesetting.
           %% Use at least 120 g/m² paper to prevent show-through.
           %% Replace with `oneside` to use one-sided typesetting;
           %% use only if you don’t have access to a double-sided
           %% printer, or if one-sided typesetting is a formal
           %% requirement at your faculty.
  nolof,     %% The `lof` option prints the List of Figures. Replace
           %% with `nolof` to hide the List of Figures.
  nolot,     %% The `lot` option prints the List of Tables. Replace
           %% with `nolot` to hide the List of Tables.
  %% More options are listed in the user guide at
  %% <http://mirrors.ctan.org/macros/latex/contrib/fithesis/guide/mu/fi.pdf>.
]{fithesis3}
%% The following section sets up the locales used in the thesis.
\usepackage[resetfonts]{cmap} %% We need to load the T2A font encoding
\usepackage[T1,T2A]{fontenc}  %% to use the Cyrillic fonts with Russian texts.
\usepackage[
  main=english, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the thesis
                %% in either Czech or Slovak, respectively.
  english, german, russian, czech, slovak %% The additional keys allow
]{babel}        %% foreign texts to be typeset as follows:
%%
%%   \begin{otherlanguage}{german}  ... \end{otherlanguage}
%%   \begin{otherlanguage}{russian} ... \end{otherlanguage}
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% For non-Latin scripts, it may be necessary to load additional
%% fonts:
\usepackage{paratype}
\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}
%%
%% The following section sets up the metadata of the thesis.
\thesissetup{
    date        = \the\year/\the\month/\the\day,
    university  = mu,
    faculty     = fi,
    type        = bc,
    author      = Ondřej Svoboda,
    gender      = m,
    advisor     = {prof. RNDr. Jiří Barnat, Ph.D.},
    title       = {Simulating RoFI Platform in GazeboSim},
    TeXtitle    = {Simulating RoFI Platform in~GazeboSim},
    keywords    = {robots, modular, simulation, GazeboSim, plugin, RoFIbot, RoFI, ...},
    TeXkeywords = {robots, modular, simulation, GazeboSim, plugin, RoFIbot, RoFI, \ldots},
    abstract    = {%
Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Fusce consectetuer risus a nunc.
Nullam rhoncus aliquam metus.
Pellentesque ipsum.
Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
Maecenas aliquet accumsan leo.
Nullam feugiat, turpis at pulvinar vulputate, erat libero tristique tellus, nec bibendum odio risus sit amet ante.
Nulla accumsan, elit sit amet varius semper, nulla mauris mollis quam, tempor suscipit diam nulla vel leo.

Vivamus luctus egestas leo.
Quisque tincidunt scelerisque libero.
Duis sapien nunc, commodo et, interdum suscipit, sollicitudin et, dolor.
Fusce suscipit libero eget elit.
Aliquam in lorem sit amet leo accumsan lacinia.
Maecenas fermentum, sem in pharetra pellentesque, velit turpis volutpat ante, in pharetra metus odio a lectus.
Vivamus porttitor turpis ac leo.
    },
    thanks      = {%
      These are the acknowledgements for my thesis, which can
      span multiple paragraphs.
    },
    bib         = references.bib,
    assignment         = assignment.pdf,
}
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight markup
\usepackage{tabularx} %% Tables
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{listings} %% Source code highlighting
\lstset{
  basicstyle      = \ttfamily,
  identifierstyle = \color{black},
  keywordstyle    = \color{blue},
  keywordstyle    = {[2]\color{cyan}},
  keywordstyle    = {[3]\color{olive}},
  stringstyle     = \color{teal},
  commentstyle    = \itshape\color{magenta},
  breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}

\newcommand{\code}[1]{\texttt{#1}}

\begin{document}
\chapter{Modular Robots}
% What is the goal of this thesis

% TODO some intro to robots


Modular robots are robots that consist of different parts -- modules.
These modules can be connected together in various ways to form a robot.
For example a human-like robot can be modular by having different types of hands as modules.
There is not a clear distinction of what is a modular robot and what is just a robot that needs to be assembled, but in general if a robot can be assembled in multiple ways to perform different tasks, then it can be called a modular robot.

Modular robots have the advantage of being able to perform various tasks depending on the modules used and the position at which the modules are connected.
Also with multiple modules, if one of the modules break, then there is no need to replace the whole robot, only the part that broke.
This can enhance replaceability and significantly lower the maintenance cost.

The major drawback is that robots, that are specifically created for one task only can be more efficient in performing this task since they do not have to make compromises.
That is why modular robots are not well suited for some specialized tasks such as manufactory work, and why they will probably never fully replace the regular ones.

\section{Self-reconfigurable robots}

A variation of modular robots are the self-reconfigurable robots.
These are robots, that are able to connect and disconnect without the help of an external force such as a human unscrewing a module and screwing a new one.
The idea of shapeshifting has been around for a long time and is possible in the robotics world with the self-reconfigurable robots.
The ability for the robotic system to change its shape according to the environment and task, make self-reconfigurable robots ideal for places, where the circumstances are not known beforehand.

Self-reconfigurable robots consist of numerous modules, that are connected together by a docking mechanism to form a combined robot.
Individual modules usually have significantly reduced moving capabilities on their own, but are capable of complex locomotions when connected together.
Self-reconfigurable robot platforms, that focus on one or two main modules are called metamorphic.
With metamorphic robots, it is possible to have specialized modules, but the majority of a robot is typically consisting of the main modules.
Therefore most of the reconfiguration of metamorphic robots is done by these main modules, which can simplify the reconfiguration algorithms.

The origins of self-reconfigurable robots can be traced back to 1990 when CEBOT (Cellular Robotic System) started at Nagoya University in Japan \cite{current-trends}.
Since then, there have been many different designs of self-reconfigurable robots focusing on different aspects of the possibilities that the self-reconfigurable robots have.
Some of these robotic designs include M-TRAN (up to M-TRAN III)\cite{mtran}, that seems to be an inspiration for a lot of the other designs, SMORES\cite{smores}, that enhances the mobility of a single module, and Roombots\cite{roombots}, which features an original way to use robots in furniture.
But through out the years, there have been dozens of different designs of modular robots \cite{current-trends}.

In order for the combined robot to perform complex task, the modules have to synchronize their movement.
This can be achieved by a centralized control or a distributed control.
The centralized control selects a master module which then controls all of the other modules.
On the other hand in the distributed control, all of the modules are controlling their own movement depending on the information about the whole combined robot.
The robot system can also use a combination of both controls such as a hierarchical control, where the modules are divided into layers and each layer gives more precise commands to the layer beneath it.


\chapter{The RoFI Platform}
% Description of the RoFI platform, what is it made of, capabilities
% what it can do, what it can't do

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{data/rofi_transformation.jpg}
    \caption{Reconfiguration capabilities of the RoFI platform. Figure taken from RoFI web page\cite{rofi-web}.}
    \label{fig:rofi-transform}
\end{figure}

RoFI is a platform for self-reconfigurable modular robots.
It is developed by a team in laboratory ParaDiSe\cite{paradise-web} at Faculty of Informatics at Masaryk University.
All information about the RoFI project and things related to it are available at the projects website\cite{rofi-web}.
The RoFI platform was firstly presented in \cite{rofi-thesis} and has been evolving since then.

The RoFI platform specifies the RoFI modules and the RoFI connection mechanics (RoFICoM).
The RoFI modules connect together by RoFICoMs to create a combined robot, that is referred to as a RoFIbot\label{rofibot} (Figure \ref{fig:rofi-transform}).

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{data/grid_aware.pdf}
    \caption{Comparison of grid-awareness in M-TRAN like and RoFI like systems. Figure taken from RoFI web page\cite{rofi-web}.}
    \label{fig:grid-aware}
\end{figure}

The RoFI modules fit into a $10 \times 10 \times 10$ cm grid.
To allow RoFI modules to turn and change position inside dense configurations, the RoFI modules are set to be grid-aware.
This removes additional constraints on the movement of modules and can simplify the algorithms for RoFI systems.
An example of such constraint is shown in Figure \ref{fig:grid-aware}, that shows a rotation in RoFI compared to M-TRAN\cite{mtran} (a grid-unaware system).
In the example, the M-TRAN modules pass through more grid cells, than is necessary.
The RoFI provides the grid-awareness by allowing the modules to fill only a sphere inside each grid cell and possibly the space between the occupied cells if two or more cells are occupied by a single module.

Each of the RoFI modules has its own control unit.
The control units of the adjacent modules can communicate together through connected RoFICoMs by a predefined interface.
The RoFI platform focuses on distributed control, because converting a distributed control to a centralized control is much easier than converting centralized control to distributed.
The RoFI also supports centralized control to great extend with RoFI OS by providing remote interface, which is shown in Figure \ref{fig:architecture}.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{data/rofi_architecture.pdf}
    \caption{RoFI software architecture diagram. Diagram taken from RoFI web page\cite{rofi-web}.}
    \label{fig:architecture}
\end{figure}

The RoFI robots are metamorphic, which means that most of the modules are meant to be the same -- the universal module.
But having only one module would notably limit the capabilities of the platform, so the RoFI platform allows specialized RoFI modules.
These could have both an actuator or a sensor as long as they have the specified interface.
In order to handle any RoFI module shape and capability, the RoFI platform specifies module descriptors\cite{rofi-thesis}.
These descriptors provide an abstraction of modules into graphs, that enables to port existing algorithms for use with RoFI.

\section{RoFICoM}
\label{roficom}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{data/connector.jpg}
    \caption{RoFICoM from the front (left) and difference between the RoFICoM in a retracted (right top) and extended (right bottom) state. Photo taken from RoFI web page\cite{rofi-web}.}
    \label{fig:connector}
\end{figure}

Since RoFI platform is designed to be grid-aware, the docking mechanism of most of the other designs of self-reconfigurable robots, such as M-TRAN\cite{mtran} or SMORES\cite{smores}, cannot be used.
In order for the connection to be inside of the grid cell sphere and to have a solid connection surface, the connector has to be retractable.
The RoFI connection mechanism (RoFICoM) is a retractable docking mechanism, that allows to create a stable connection between two RoFI modules.

To increase the flexibility of the RoFI system, the RoFICoMs are created genderless (that means, that any two RoFICoMs can be connected together) and can be connected in multiple ways.
Since the grid is cubical, the RoFICoM respects this and allows to be connected in four orientations.
These orientations are north, east, west and south and are the same from perspectives of both connected RoFICoMs.

Because the connection between two modules is frequent and essential for the modular system, the connection is required not to drain energy in a connected state.
This eliminates the use of docks based on electromagnets.
The RoFICoMs are taking advantage of the need to be retractable and use a hooking system to create the connection.
This connection does not drain any energy except when the RoFICoM is either extending or retracting.
The hooking system implies, that a RoFICoM can connect to other nearby RoFICoM when either both of the RoFICoMs are extending or one is extending and the other is already extended.
To deal with potential dead modules, the RoFICoM connection can be disconnected by any of the two mating sides without the assistance of the connected module.
The unnecessity of any action from the opposite side makes it possible to create a floor of extended RoFICoM-like hooks, to which the modules can connect.

The mechanical construction of RoFICoM nullifies the possibility of connecting wrong angle -- either the RoFICoMs connect and then they align perfectly in one orientation, or they do not connect at all.
The construction allows some tolerance on the positioning and alignments of the connecting RoFICoMs.
The area of acceptance for RoFICoMs can be seen at \cite[p. 6]{roficom}.

The RoFICoM has several pins at the middle of the connecting plane.
These pins enable communicating between RoFICoMs, sensing connected RoFICoMs and power sharing.
The communication protocol between RoFICoMs allows sending any data with error detection.
The sensing pin allows the RoFICoM to check if an opposing side RoFICoM is connected and if so, the pin can also tell the orientation of the connection.
The power sharing property allows a RoFI module to charge other modules or to be charged by other modules.
It also allows to close entirely or to enter a survivor mode, where it is only used to pass packets.
More information about the capabilities of a RoFICoM can be found at \cite{roficom} and \cite{rofi-web}.

\section{Universal Module}
\label{univ-module}

\begin{figure}
    \centering
    \includegraphics[height=.3\textheight]{data/mtran3.jpg}
    \includegraphics[height=.4\textheight]{data/rofi_universal_module.jpg}
    \caption{Comparison of a M-TRAN module (left) with a RoFI universal module (right). Photos taken from M-TRAN web page\cite{mtran-web} and RoFI web page\cite{rofi-web}.}
    \label{fig:mtran-rofi}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[height=.4\textheight]{data/rofi_universal_module_dof.pdf}
    \caption{Illustration of three degrees of freedom in RoFI universal module. Picture taken from RoFI web page\cite{rofi-web}.}
    \label{fig:univ-module-dof}
\end{figure}

Universal module is a RoFI module, that is the main building block of the RoFI platform.
The universal module is inspired by the M-TRAN\cite{mtran} module.
The comparison of the two modules can be seen in Figure \ref{fig:mtran-rofi}.
Both the M-TRAN and RoFI modules are composed of two shoes, that occupy one grid cell each, connected together by the body.
Each shoe can rotate around an axis going through its center.
The RoFI universal module has an additional rotational axis compared to M-TRAN, that is going through the middle of the module body (see Figure \ref{fig:univ-module-dof}).
The range of motion allows each shoe to have three connectors.
Note that M-TRAN has gendered connectors, where as RoFI has genderless connectors.

The RoFI universal module uses ESP32 microprocessor as the control unit.
The ESP32 provides a POSIX compatible interface and the full C++ standard library, which simplifies the development of software for the universal modules.
The module utilizes servo motors for rotation.
The servo motors allow position and speed controlling the joint on top of the force controlling.
This allows to distribute the responsibilities of the control unit and offers a tested and concise controller that speeds up the development of the RoFI platform.


\chapter{Robotic Virtual Simulator}
% What is a robotic simulator (for those, who never heard of it)
% Why is it beneficial, what are advantages/disadvantages

A robotic virtual simulator is a computer software that enables the programmer or designer to observe how the robot behaves in different situations.
The simulator is dependent on the physics engine, that computes all movement and collisions of every object in the simulation.
This physics engine can be fixed for some simulators such as Webots\cite{webots} or the user can select a physics engine from multiple choices as in GazeboSim\cite{gazebo}.

There are many advantages to having a virtual simulator for a robot.
The most apparent one is that it reduces the necessity of having a physical robot at hand.
It also nullifies any possibility of breaking the physical robot and allows testing robots in diverse environments and robot quantities -- which would be costly, especially at the beginning of the robot development.
The major disadvantage comes from the imperfect accuracy of the physics engine. There is an effort in the robotics community to improve the accuracy, but this often leads to increased requirements.

Since virtual simulation for any robot has many advantages and almost no disadvantages besides accuracy and implementation time, virtualization is usual among many teams that develop robots.
Therefore there is software that tries to make implementing simulation for a robot as simple as possible.
One such software is the Robot Operating System (ROS), which allows its users to use the same operating system for their physical robot and the robot in a simulation.
ROS uses the Gazebo simulator (GazeboSim) for the simulation, and so both ROS and GazeboSim are widely used and have a large user community.
% TODO look at the paragraph and possibly rephrase

\section{Virtual Simulator for Modular Robots}
% What is the difference against normal simulator

Modular robots systems usually have multiple modules and even the interaction between the modules can have significant impact on the behaviour of the system from the outside.
Simulating modular robots is therefore even more important, since the outcome of a users code is not so clear.
But there are also obsticles when creating such simulator, that will not arise with simulating regular robots.

Modular robots depend heavily on the connection between the modules and it often has complicated mechanisms to ensure stability.
If the connection system would be created as it is in the real world, these mechanisms would often cause high computation load and the imperfection of the physics computing model would probably cause instabilities in the virtual simulator.
But for the aim of the simulation, the virtual simulator can ignore these connection mechanisms and only reflect the outcome of these connections.

\section{Available Modular Robotic Simulators}
% What robotic simulators exist
% Why do we need a new thing

One example of a simulator for modular robots is the Unified Simulator for Self-Reconfigurable Robots (USSR)\cite{ussr}, which addresses
the connectivity problem with addition to a scalability problem.
These simulators often try to solve more aspects of simulating modular robots, but at the cost of precision and user-friendliness.
Many of these simulators have not received an update for years, so lack of evolution and support is a substantial drawback for these simulators.


\chapter{RoFI Simulator Design}

\section{Platform Selection}
% why Gazebo and not doing it from scratch, why not Unity or other simulator for modular robots

There are few options on how to address constraints on simulating modular robots:
\begin{enumerate}
    \item Use a dedicated simulator for modular robots, that is either already created, or made from scratch.
    \item Use a generic simulator and add the required capabilities.
\end{enumerate}

The main reason to use a generic robotic simulator is the continuous improvements of the simulator and the developers and community support.
Many teams design robots today, and most of them use a virtual simulator of some kind, so it is reasonable to assume that the simulators used a lot today will continue to progress and support in the future.
These widely used simulators have a way to customize or extend the functionality of the simulator by using plugins, such as GazeboSim\cite{gazebo} and Webots\cite{webots}, or macros, such as RoboDK\cite{robodk}.

% TODO why exactly Gazebo

\section{Overall Design}
% why client/server
% other posibility: compilating to plugin
% why one process/one rofi (e.g. SIGKILL)
% why HAL
% diagram about interfaces - where stands gazebo, plugins, models, user code, hal, ...

% pid controller
% messages

% TODO diagram of simulator design

\subsection{HAL Interface}

Diagram \ref{fig:architecture} shows the RoFI software architecture.
The RoFI hardware abstraction layer (HAL) allows the user that programs RoFI modules code to not worry about the implementation details of the hardware.
Providing the same HAL interface in the simulator as well as the physical RoFI modules enables to use the same code for the physical modules and the simulator.

\subsection{Gazebo Integration}

Gazebo allows extending its functionality by various plugins.
The obvious choice is to have each RoFI module have its model with a model plugin attached.
This model plugin will be simulating a processor in the physical module.

One possible design would be to compile each RoFI program into a separate plugin and each simulated RoFI module will have a plugin corresponding to the code loaded in the physical module.
This approach makes the implementation fairly simple, because it mostly just copies the physical implementation.
But there are flaws in this design as well:
\begin{itemize}
    \item When the user program would fail and terminate (e.g. because of a SIGKILL), the whole simulation would collapse, because Gazebo runs all plugins in the same process.
    \item In case of few different codes, each generated plugin would have to be available to Gazebo and specified with its own name in the world description.
    \item It eliminates (or makes really difficult) the possibility of changing the code during the simulation.
\end{itemize}

The other design, which is used in this thesis, is to make use of Gazebo topics, which allow communication between Gazebo and third party software.
In this design each module has a client side and a server side.
The server is a model plugin attached to the RoFI module, which interprets Gazebo command messages.
The client side is the users program with a small layer, that translates the RoFI HAL commands to Gazebo messages, which can be processed by the server.

The client/server separation allows to separate processes of each module and thus better imitate the physical reality.
This could also be used to imitate the limited capabilities of the microprocessor used in RoFI modules.
But there are some negative elements that have to be considered in this approach:
\begin{itemize}
    \item There is no guarantee, that the message will arrive.
    \item Even if the messages arrive, they could be delayed or reordered.
    \item There is a need for a mechanism, that will determine what the topic address will be.
\end{itemize}

\subsection{RoFICoM Model}

RoFICoM (\ref{roficom}) is a key component to all RoFI modules and in most modules is featured multiple times.
Because of this and because RoFICoM has many special requirements, it's convinient to have an isolated RoFICoM model.
This also allows distributing the work from the RoFI module plugin to several RoFICoM plugins.

The communication between RoFI module plugin and RoFICoM plugins is done by Gazebo messages.
Due to Gazebo allowing only unique scoped names for models and both plugins having access to the RoFICoM model, the communication topic is the scoped name of the RoFICoM model.

\subsection{Creating Modules}

The only module that the RoFI platform specifies at the time of writing is the Universal module (\ref{univ-module}).
But since RoFIbots (\ref{rofibot}) are expected to be consisting of various different RoFI modules, there is an easy way to create a new module (see Section \ref{ex-modules}).

\section{Challenges}
% difficulties in the design: what needs to be done, clients, connecting roficoms, saving world and reloading (saving plugin info to sdf), waiting

During the implementation there were few challenges to overcome.
Here are some of the more important ones with outline of the solutions and reasoning behind them.

\subsection{Distributing the RoFI Modules}

The RoFI module in the simulation has no information about its id, which is used to address individual modules inside the code.
This is due to the fact, that the module can be inserted into the simulation after the start and each inserted module is the same except for the model name.
The RoFI modules plugins have to know the topic at the loading of the model, so it can communicate with rest of the simulation, so the used topic is the scoped name of the module model (as with the RoFICoM model plugin).

The client also does not know the id and the topic of the local RoFI module.
This could be solved by providing the id in each client, but this is not well scalable as many applications use the same software in all modules.

The solution utilizes a \emph{distributor} world plugin, that registers all RoFI modules in the world.
The \emph{distributor} is able to lock or free a RoFI module and give info (ids and topics) about the registered RoFI modules.

\subsection{Publishing Messages from the Client}

Gazebo messages use the best-effort delivery and thus may get lost.
This is a problem especially in callback based user code.
The aim was to improve the reliability by creating a publish worker, so all messages from one client are sent from the same thread.
This improved the reliability, but some messages could still get lost if the host machine is slow and multiple messages are sent at the same time.
It is possible to implement a TCP above the Gazebo messages, but that is above the scope of this thesis.

\subsection{Connecting RoFICoMs in Simulation}

The biggest challenge in simulating modular robots in a general simulator is to mimic the behaviour of the docking system.
The RoFICoM has some tolerance\cite{roficom} on the area of acceptance and if connected, will perfectly align the two RoFICoMs.

An elegant solution would be to create a joint between the two RoFICoMs and connect them.
But since the models can be further apart, be rotated and misaligned at the same time, a combination of multiple joints would have to be made.
(Note that RoFICoMs connect only in 4 orientations.)
Unfortunately Gazebo is limited and uneasy to use in terms of creating joints at the runtime, so creating multiple joints becomes increasingly more difficult.

Another way is to use four points on the RoFICoM model and join these with a spring-like mechanism.
This has the advantage of only switching points that join to each other, when connecting RoFICoMs with different orientation.

\subsection{Saving and Loading Worlds with State}

When saving a Gazebo world, the information is saved in a SDFormat.
All the model and joint positions as well as velocities are saved, but no information about the plugins are saved.
This can lead to a situation, where a RoFICoM is half extended, which would never happen in real life.
Also the target positions, velocities or forces are forgotten and there is no telling even which movement mode was used.

A possibility would be to just say that it is undefined, but saving and reloading worlds is a useful feature, and it makes sense to keep it.
Other possibility would be to save the state of the plugin to the SDFormat.
This adds some overhead on runtime, because the SDFormat has to be updated all the time, but this overhead seems negligible.

\subsection{Waiting in the Client}

Since the simulation can run at a different speed than real time (slower if the host machine is slow or even faster if Gazebo is set to do so), the standard function \code{sleep\_for} will not work as expected.

In the RoFI team we decided to provide a function \code{RoFI::wait} (that takes the waiting time and a callback) in the RoFI HAL.
Since the function \code{wait} can be called multiple times, each wait is assigned an id and sent to the local module plugin, that uses the simulation time for waiting.
Note that since every RoFI module is assigned at most one client, the wait ids can be for each client the same.


\chapter{Experimental Evaluation}
% examples, demos
% what works, what does not - how much does it not work

\section{Creating New Modules}
\label{ex-modules}

% TODO

\section{Examples}

\subsection{Double Wheel}

% TODO

\section{Creating Worlds}

\subsection{Wheel}
% TODO

\subsection{Spider}
% TODO

\subsection{50 Modules}
% TODO


\chapter{Conclusion}
% How I managed to make an awesome tool, that will help the world

\end{document}
